# ~/.bashrc

# ---------
#  options
# ---------

# autocd: dirnames as cd commands.
# cdspell: spelling mistakes.
# histappend: append to the history file.
# checkwinsize: update the values of LINES and COLUMNS.
# globstar: ** matches files on subdirectories
shopt -s autocd cdspell histappend checkwinsize globstar

bind 'Control-q: "\C-a\C-k\C-d"'
bind '"\eh": backward-kill-word'
bind '"\e\t": menu-complete'
bind '"\e\e[Z": menu-complete-backward'

stty -ixon

# -------------
#  Environment
# -------------

unset MAIL MAILCHECK
export HISTFILESIZE=2000

export BAT_THEME='ansi'
export CONAN_HOME="$HOME/.local/share/conan2"

export PATH="$HOME/.local/bin:$PATH"
export MANPATH="$HOME/.local/share/man:$MANPATH"

export VISUAL=vim
export EDITOR=vim
export SUDO_EDITOR=vim

export LESS='--ignore-case --incsearch --mouse --use-color --RAW-CONTROL-CHARS'
export MANPAGER="sh -c 'awk '\''{ gsub(/\x1B\[[0-9;]*m/, \"\", \$0); gsub(/.\x08/, \"\", \$0); print }'\'' | bat --style=plain --paging=always --language=man'"

export VIRTUAL_ENV_DISABLE_PROMPT=1
export LIBVIRT_DEFAULT_URI='qemu:///system'

export DEBEMAIL="lucasllort@gmail.com"
export DEBFULLNAME="Lucas Llort"

# -------------
#  Completions
# -------------

. /usr/share/bash-completion/bash_completion

for completion in "$HOME/.local/share/bash-completion/completions/"*; do
    [[ -r "$completion" ]] && source "$completion"
done


# ---------
#  Aliases
# ---------

alias mna='man'
alias atp='apt'
alias cim='vim'
alias nivm='nvim'
alias ncim='nvim'
alias suod='sudo'

alias l='ls'
alias sl='ls'
alias ls='ls --color=auto --hyperlink=auto --classify=auto'
alias ll='ls -l --human-readable'
alias la='ls --all'
alias lal='ll --all'
alias lla='lal'

alias cd..='cd ..'

alias shimbolic='ln --symbolic /dev/shm .'
alias virsh='virsh -c qemu:///system'

if [[ $TERM == 'xterm-kitty' ]]; then 
    alias clear="printf '\e[H\e[22J'"
    bind -x '"\C-l":echo; clear'
fi

function export-vulkan {
    source "$HOME/Programs/vulkansdk-1.4.335.0/setup-env.sh"
    unset -f $FUNCNAME
}

function export-idf {
    source $HOME/Repos/esp-idf/export.sh
    unset -f $FUNCNAME
}

function just {
    $@ &>/dev/null &
    disown '%%';
}

function envexport {
    local env_filename="$1"
    if [[ -z "$env_filename" ]]; then
        env_filename=".env"
    fi

    local env_path="$(back-search -f "$env_filename")"

    if [[ ! -z $env_path ]]; then
        set -o allexport
        source "$env_path"
        set +o allexport
        cat "$env_path"
        return 0
    fi

    echo "File \"$env_filename\" not found."
    return 1
}

function project-source {
    local proj_filename="$1"
    if [[ -z "$proj_filename" ]]; then
        proj_filename=".proj"
    fi

    local proj_path="$(back-search -f "$proj_filename")"

    if [[ ! -z $proj_path ]]; then
        source "$proj_path"
        return 0
    fi

    echo "File \"$proj_filename\" not found."
    return 1
}

function pyactivate {
    if [[ -v VIRTUAL_ENV ]]; then
        echo "Enviroment variable VIRTUAL_ENV is set, deactivate the current virtual environment."
        return 1
    fi

    if [[ -z $1 ]]; then
        local dot_path="$(back-search -d ".venv/bin")"
        local simple_path="$(back-search -d "venv/bin")"

        if [[ ${#dot_path} -gt ${#simple_path} ]]; then
            local script_path="$dot_path"
        else
            local script_path="$simple_path"
        fi

    else 
        local script_path="$(back-search -d "$1/bin")"
    fi

    if [[ -z $script_path ]]; then
        echo "Virtual environment not found."
        return 1
    fi

    source "$script_path/activate"
    echo "VIRTUAL_ENV=$(pretty_path $VIRTUAL_ENV)"

    if [[ -x $script_path/pip ]]; then 
        eval "$("$script_path/pip" completion --bash)"
    elif [[ -x $(command -v uv) ]]; then
        eval "$(uv generate-shell-completion bash)"
    fi

    return 0
}

function back-search {
    local current_dir="$PWD"

    while [[ -n "$current_dir" ]]; do
        local found_path="$current_dir/$2" 

        if test $1 "$found_path"; then
            echo $found_path
            return 0
        fi

        current_dir=${current_dir%/*}
    done

    return 1
}

function pretty_path {
    local res=${1#$PWD}
    if [[ $res != $1 ]]; then
        echo ".$res"
        return
    fi

    local prev_dir=${PWD%/*}
    res=${1#$prev_dir}
    if [[ $res != $1 ]]; then
        echo "..$res"
        return
    fi

    res=${1#$HOME}
    if [[ $res != $1 ]]; then
        echo "~$res"
        return
    fi
}


# --------
#  Prompt
# --------

reset=$'\e[0m'
dark_white=$'\e[37m'
bright_black=$'\e[90m'
bright_red=$'\e[91m'
bright_blue=$'\e[94m'
bright_magenta=$'\e[95m'
bright_cyan=$'\e[96m'
bright_white=$'\e[97m'

logo_col="$bright_red"
host_col="$bright_blue"
dir_col="$bright_magenta"
git_col="$bright_cyan"
exit_col="$bright_red"
prompt_col="$bright_white"
no_col="$reset"

prompt_icon='$'
dir_sep='...'

git_branch='(b:'
git_tag='(t:'
git_commit='(c:'
git_end=')'

exit_icon='(e:'
exit_end=')'

if [[ "$TERM" == "xterm-kitty" ]]; then
    logo_icon=' '
    prompt_icon=''
    dir_sep='....'

    git_branch=''
    git_tag=''
    git_commit=''
    git_end=''

    exit_icon=''
    exit_end=''

    bslash='\\'

    ps1_start=$'\e]133;A\e'$bslash
    ps1_end=$'\e]133;B\e'$bslash

    ps2_start=$'\e]133;A;k=s\e'$bslash
    ps2_end=$'\e]133;B;k=s\e'$bslash

    cmd_start=$'\e]133;C\e'$bslash
    cmd_end=$'\e]133;D;$?\e'$bslash
fi

exit_status=''
short_dir=''
git_status=''
git_status_update_pending=1; 

alias cd='git_status_update_pending=1; builtin cd'
alias git='git_status_update_pending=1; git'
alias lazygit='git_status_update_pending=1; lazygit'

function update_git_status {
    # if on a branch
    git_status=$(git symbolic-ref --short HEAD 2>/dev/null)
    if [[ -n $git_status ]]; then
        git_status="$git_branch $git_status$git_end "
        return
    fi

    # if on a tag
    git_status=$(git describe --tags --exact-match 2>/dev/null)
    if [[ -n $git_status ]]; then
        git_status="$git_tag $git_status$git_end "
        return
    fi

    # else use commit hash
    git_status="$git_commit $(git rev-parse --short HEAD 2>/dev/null)$git_end "
}

function update_prompt {
    # update exit status
    exit_status=$?
    if [[ $exit_status == 0 ]]; then
        exit_status=''
    else
        exit_status="$exit_icon $exit_status$exit_end "
    fi

    # update formatted dir
    short_dir="$PWD"
    if [[ $short_dir == '/' ]]; then
        short_dir='/'
    else
        short_dir=${short_dir/#$HOME/'~'}
        short_dir=${short_dir#/}
        short_dir=${short_dir/\/*\//\/$dir_sep\/}
    fi

    if [[ -n "$git_status_update_pending" ]]; then
        git_status_update_pending=''
        git_status=''
        git_dir=$(back-search -d .git)
        [[ $? == 0 ]] && update_git_status
    fi
}

PROMPT_COMMAND=update_prompt
PS0="\[$cmd_start\]"

PS1="\
\[$cmd_end\
$ps1_start\
$no_col\
$logo_col\]$logo_icon\
\[$host_col\]\u@\H \
\[$dir_col\]\$short_dir \
\[$git_col\]\$git_status\
\[$exit_col\]\$exit_status\
\[$prompt_col\]$prompt_icon \
\[$no_col\
$ps1_end\]"

PS2="\
\[$ps2_start\]\
\[$prompt_col\]$prompt_icon \
\[$no_col\
$ps2_end\]"

